/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import {
  AudioEncoding,
  AudioWebsocketProtocol,
  AudioEncoding$,
  AudioWebsocketProtocol$,
} from "../../models/components";
import * as components from "../../models/components";
import { z } from "zod";

export type RegisterCallRequestBody = {
  /**
   * Corresponding agent id of this call.
   */
  agentId: string;
  /**
   * The audio encoding of the call.
   */
  audioEncoding: AudioEncoding;
  /**
   * Sample rate of the conversation, the input and output audio bytes will all conform to this rate. Check the audio source, audio format, and voice used for the agent to select one that works.
   */
  sampleRate: number;
  /**
   * The protocol how audio websocket read and send audio bytes.
   */
  audioWebsocketProtocol: AudioWebsocketProtocol;
  /**
   * If users stay silent for a period, end the call. By default, it is set to 600,000 ms (10 min). The minimum value allowed is 10,000 ms (10 s).
   */
  endCallAfterSilenceMs?: number | undefined;
  /**
   * The caller number. This field is storage purpose only, set
                    this if you want the call object to contain it so that it's
                    easier to reference it. Not used for processing, when we
                    connect to your LLM websocket server, you can then get it
                    from the call object.
   */
  fromNumber?: string | undefined;
  /**
   * The callee number. This field is storage purpose only, set
                    this if you want the call object to contain it so that it's
                    easier to reference it. Not used for processing, when we
                    connect to your LLM websocket server, you can then get it
                    from the call object.
   */
  toNumber?: string | undefined;
  /**
   * An abtriary object for storage purpose only. You can put
                    anything here like your own id for the call, twilio SID,
                    internal customer id. Not used for processing, when we
                    connect to your LLM websocket server, you can then get it
                    from the call object.
   */
  metadata?: Record<string, any> | undefined;
};

export type RegisterCallResponse = {
  /**
   * Successfully retrieved a call.
   */
  callDetail?: components.CallDetail | undefined;
  /**
   * HTTP response content type for this operation
   */
  contentType: string;
  /**
   * HTTP response status code for this operation
   */
  statusCode: number;
  /**
   * Raw HTTP response; suitable for custom response parsing
   */
  rawResponse: Response;
};

/** @internal */
export namespace RegisterCallRequestBody$ {
  export type Inbound = {
    agent_id: string;
    audio_encoding: AudioEncoding;
    sample_rate: number;
    audio_websocket_protocol: AudioWebsocketProtocol;
    end_call_after_silence_ms?: number | undefined;
    from_number?: string | undefined;
    to_number?: string | undefined;
    metadata?: Record<string, any> | undefined;
  };

  export const inboundSchema: z.ZodType<
    RegisterCallRequestBody,
    z.ZodTypeDef,
    Inbound
  > = z
    .object({
      agent_id: z.string(),
      call_id: z.string(),
      audio_encoding: AudioEncoding$,
      sample_rate: z.number().int(),
      audio_websocket_protocol: AudioWebsocketProtocol$,
      end_call_after_silence_ms: z.number().int().optional(),
      from_number: z.string().optional(),
      to_number: z.string().optional(),
      metadata: z.record(z.any()).optional(),
    })
    .transform((v) => {
      return {
        agentId: v.agent_id,
        audioEncoding: v.audio_encoding,
        sampleRate: v.sample_rate,
        audioWebsocketProtocol: v.audio_websocket_protocol,
        ...(v.end_call_after_silence_ms === undefined ? null : { endCallAfterSilenceMs: v.end_call_after_silence_ms }),
        ...(v.from_number === undefined ? null : { fromNumber: v.from_number }),
        ...(v.to_number === undefined ? null : { toNumber: v.to_number }),
        ...(v.metadata === undefined ? null : { metadata: v.metadata }),
      };
    });

  export type Outbound = {
    agent_id: string;
    audio_encoding: components.AudioEncoding;
    sample_rate: number;
    audio_websocket_protocol: components.AudioWebsocketProtocol;
    end_call_after_silence_ms?: number | undefined;
    from_number?: string | undefined;
    to_number?: string | undefined;
    metadata?: Record<string, any> | undefined;
  };

  export const outboundSchema: z.ZodType<
    Outbound,
    z.ZodTypeDef,
    RegisterCallRequestBody
  > = z
    .object({
      agentId: z.string(),
      audioEncoding: AudioEncoding$,
      sampleRate: z.number().int(),
      audioWebsocketProtocol: AudioWebsocketProtocol$,
      endCallAfterSilenceMs: z.number().int().optional(),
      fromNumber: z.string().optional(),
      toNumber: z.string().optional(),
      metadata: z.record(z.any()).optional(),
    })
    .transform((v) => {
      return {
        agent_id: v.agentId,
        audio_encoding: v.audioEncoding,
        sample_rate: v.sampleRate,
        audio_websocket_protocol: v.audioWebsocketProtocol,
        ...(v.endCallAfterSilenceMs === undefined ? null : { end_call_after_silence_ms: v.endCallAfterSilenceMs }),
        ...(v.fromNumber === undefined ? null : { from_number: v.fromNumber }),
        ...(v.toNumber === undefined ? null : { to_number: v.toNumber }),
        ...(v.metadata === undefined ? null : { metadata: v.metadata }),
      };
    });
}

/** @internal */
export namespace RegisterCallResponse$ {
  export type Inbound = {
    CallDetail?: components.CallDetail$.Inbound | undefined;
    ContentType: string;
    StatusCode: number;
    RawResponse: Response;
  };

  export const inboundSchema: z.ZodType<
    RegisterCallResponse,
    z.ZodTypeDef,
    Inbound
  > = z
    .object({
      CallDetail: components.CallDetail$.inboundSchema.optional(),
      ContentType: z.string(),
      StatusCode: z.number().int(),
      RawResponse: z.instanceof(Response),
    })
    .transform((v) => {
      return {
        ...(v.CallDetail === undefined ? null : { callDetail: v.CallDetail }),
        contentType: v.ContentType,
        statusCode: v.StatusCode,
        rawResponse: v.RawResponse,
      };
    });

  export type Outbound = {
    CallDetail?: components.CallDetail$.Outbound | undefined;
    ContentType: string;
    StatusCode: number;
    RawResponse: never;
  };

  export const outboundSchema: z.ZodType<
    Outbound,
    z.ZodTypeDef,
    RegisterCallResponse
  > = z
    .object({
      callDetail: components.CallDetail$.outboundSchema.optional(),
      contentType: z.string(),
      statusCode: z.number().int(),
      rawResponse: z.instanceof(Response).transform(() => {
        throw new Error("Response cannot be serialized");
      }),
    })
    .transform((v) => {
      return {
        ...(v.callDetail === undefined ? null : { CallDetail: v.callDetail }),
        ContentType: v.contentType,
        StatusCode: v.statusCode,
        RawResponse: v.rawResponse,
      };
    });
}
